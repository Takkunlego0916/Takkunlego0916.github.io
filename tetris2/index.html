<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>テトリス v2</title>

  <!-- Tailwind Play CDN for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    /* 小さな調整（必要ならここで上書き） */
    body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React / ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel for JSX in-browser transpile (開発用) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- アプリ本体 -->
  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    /* --- シンプルな Button コンポーネント（元の UI Button の代替） --- */
    function Button({ children, onClick, className = '', variant, size, disabled }) {
      const base = "inline-flex items-center justify-center rounded-md px-3 py-1 text-sm";
      const disabledClass = disabled ? "opacity-50 cursor-not-allowed" : "hover:opacity-90";
      return (
        <button onClick={onClick} disabled={disabled} className={\`\${base} \${className} \${disabledClass}\`}>
          {children}
        </button>
      );
    }

    /* --- 簡易アイコン（SVG） --- */
    const Icon = {
      Play: (props) => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...props}>
          <path d="M5 3v18l15-9L5 3z" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
        </svg>
      ),
      Pause: (props) => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...props}>
          <path d="M6 4h4v16H6zM14 4h4v16h-4z" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
        </svg>
      ),
      RotateCcw: (props) => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...props}>
          <path d="M21 12a9 9 0 10-3.2 6.6L21 12z" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
        </svg>
      ),
      RotateCw: (props) => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...props}>
          <path d="M3 12a9 9 0 013.2-6.6L3 12z" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
        </svg>
      ),
      ChevronDown: (props) => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...props}>
          <path d="M6 9l6 6 6-6" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
        </svg>
      ),
      ChevronLeft: (props) => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...props}>
          <path d="M15 18l-6-6 6-6" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
        </svg>
      ),
      ChevronRight: (props) => (
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" {...props}>
          <path d="M9 6l6 6-6 6" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
        </svg>
      ),
    };

    /* --- ゲーム定数 --- */
    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const INITIAL_SPEED = 800;

    const TETROMINOS = {
      I: { shape: [[1,1,1,1]], color: 'bg-cyan-400 shadow-cyan-400/50' },
      O: { shape: [[1,1],[1,1]], color: 'bg-yellow-400 shadow-yellow-400/50' },
      T: { shape: [[0,1,0],[1,1,1]], color: 'bg-purple-500 shadow-purple-500/50' },
      S: { shape: [[0,1,1],[1,1,0]], color: 'bg-green-400 shadow-green-400/50' },
      Z: { shape: [[1,1,0],[0,1,1]], color: 'bg-red-500 shadow-red-500/50' },
      J: { shape: [[1,0,0],[1,1,1]], color: 'bg-blue-500 shadow-blue-500/50' },
      L: { shape: [[0,0,1],[1,1,1]], color: 'bg-orange-500 shadow-orange-500/50' },
    };
    const TETROMINO_KEYS = Object.keys(TETROMINOS);

    const createEmptyBoard = () => Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
    const randomTetromino = () => {
      const key = TETROMINO_KEYS[Math.floor(Math.random() * TETROMINO_KEYS.length)];
      return { ...TETROMINOS[key], type: key };
    };
    const rotate = (matrix) => {
      const rows = matrix.length;
      const cols = matrix[0].length;
      const rotated = Array.from({ length: cols }, () => Array(rows).fill(0));
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          rotated[c][rows - 1 - r] = matrix[r][c];
        }
      }
      return rotated;
    };

    /* --- Tetris コンポーネント --- */
    function Tetris() {
      const [board, setBoard] = useState(createEmptyBoard());
      const [currentPiece, setCurrentPiece] = useState(null);
      const [nextPiece, setNextPiece] = useState(null);
      const [position, setPosition] = useState({ x: 0, y: 0 });
      const [score, setScore] = useState(0);
      const [lines, setLines] = useState(0);
      const [level, setLevel] = useState(1);
      const [gameOver, setGameOver] = useState(false);
      const [isPaused, setIsPaused] = useState(false);
      const [isPlaying, setIsPlaying] = useState(false);

      const gameLoopRef = useRef(null);

      const checkCollision = useCallback((piece, pos, boardState) => {
        if (!piece) return false;
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              const newX = pos.x + x;
              const newY = pos.y + y;
              if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) return true;
              if (newY >= 0 && boardState[newY][newX]) return true;
            }
          }
        }
        return false;
      }, []);

      const mergePiece = useCallback(() => {
        if (!currentPiece) return board;
        const newBoard = board.map(row => [...row]);
        for (let y = 0; y < currentPiece.shape.length; y++) {
          for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
              const boardY = position.y + y;
              const boardX = position.x + x;
              if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                newBoard[boardY][boardX] = currentPiece.color;
              }
            }
          }
        }
        return newBoard;
      }, [board, currentPiece, position]);

      const clearLines = useCallback((boardState) => {
        let clearedLines = 0;
        const newBoard = boardState.filter(row => {
          if (row.every(cell => cell !== null)) {
            clearedLines++;
            return false;
          }
          return true;
        });
        while (newBoard.length < BOARD_HEIGHT) {
          newBoard.unshift(Array(BOARD_WIDTH).fill(null));
        }
        return { newBoard, clearedLines };
      }, []);

      const spawnPiece = useCallback(() => {
        const piece = nextPiece || randomTetromino();
        const newNext = randomTetromino();
        const startX = Math.floor((BOARD_WIDTH - piece.shape[0].length) / 2);
        const startPos = { x: startX, y: 0 };

        if (checkCollision(piece, startPos, board)) {
          setGameOver(true);
          setIsPlaying(false);
          return;
        }

        setCurrentPiece(piece);
        setNextPiece(newNext);
        setPosition(startPos);
      }, [nextPiece, board, checkCollision]);

      const moveDown = useCallback(() => {
        if (!currentPiece || isPaused || gameOver) return;

        const newPos = { x: position.x, y: position.y + 1 };
        if (checkCollision(currentPiece, newPos, board)) {
          const mergedBoard = mergePiece();
          const { newBoard, clearedLines } = clearLines(mergedBoard);
          setBoard(newBoard);

          if (clearedLines > 0) {
            const points = [0,100,300,500,800][clearedLines] * level;
            setScore(prev => prev + points);
            setLines(prev => {
              const newLines = prev + clearedLines;
              if (Math.floor(newLines / 10) > Math.floor(prev / 10)) {
                setLevel(l => l + 1);
              }
              return newLines;
            });
          }

          setCurrentPiece(null);
        } else {
          setPosition(newPos);
        }
      }, [currentPiece, position, board, isPaused, gameOver, checkCollision, mergePiece, clearLines, level]);

      const moveHorizontal = useCallback((dir) => {
        if (!currentPiece || isPaused || gameOver) return;
        const newPos = { x: position.x + dir, y: position.y };
        if (!checkCollision(currentPiece, newPos, board)) {
          setPosition(newPos);
        }
      }, [currentPiece, position, board, isPaused, gameOver, checkCollision]);

      const rotatePiece = useCallback(() => {
        if (!currentPiece || isPaused || gameOver) return;
        const rotated = { ...currentPiece, shape: rotate(currentPiece.shape) };
        if (!checkCollision(rotated, position, board)) {
          setCurrentPiece(rotated);
        }
      }, [currentPiece, position, board, isPaused, gameOver, checkCollision]);

      const hardDrop = useCallback(() => {
        if (!currentPiece || isPaused || gameOver) return;
        let newY = position.y;
        while (!checkCollision(currentPiece, { x: position.x, y: newY + 1 }, board)) {
          newY++;
        }
        setPosition({ x: position.x, y: newY });
      }, [currentPiece, position, board, isPaused, gameOver, checkCollision]);

      useEffect(() => {
        if (!currentPiece && isPlaying && !gameOver) {
          spawnPiece();
        }
      }, [currentPiece, isPlaying, gameOver, spawnPiece]);

      useEffect(() => {
        if (!isPlaying || isPaused || gameOver) {
          if (gameLoopRef.current) clearInterval(gameLoopRef.current);
          return;
        }

        const speed = Math.max(100, INITIAL_SPEED - (level - 1) * 80);
        gameLoopRef.current = setInterval(moveDown, speed);

        return () => {
          if (gameLoopRef.current) clearInterval(gameLoopRef.current);
        };
      }, [isPlaying, isPaused, gameOver, level, moveDown]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if (!isPlaying || gameOver) return;

          switch (e.key) {
            case 'ArrowLeft':
              e.preventDefault();
              moveHorizontal(-1);
              break;
            case 'ArrowRight':
              e.preventDefault();
              moveHorizontal(1);
              break;
            case 'ArrowDown':
              e.preventDefault();
              moveDown();
              break;
            case 'ArrowUp':
              e.preventDefault();
              rotatePiece();
              break;
            case ' ':
              e.preventDefault();
              hardDrop();
              break;
            case 'p':
            case 'P':
              setIsPaused(prev => !prev);
              break;
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [isPlaying, gameOver, moveHorizontal, moveDown, rotatePiece, hardDrop]);

      const startGame = () => {
        setBoard(createEmptyBoard());
        setCurrentPiece(null);
        setNextPiece(randomTetromino());
        setPosition({ x: 0, y: 0 });
        setScore(0);
        setLines(0);
        setLevel(1);
        setGameOver(false);
        setIsPaused(false);
        setIsPlaying(true);
      };

      const renderBoard = () => {
        const displayBoard = board.map(row => [...row]);

        if (currentPiece) {
          for (let y = 0; y < currentPiece.shape.length; y++) {
            for (let x = 0; x < currentPiece.shape[y].length; x++) {
              if (currentPiece.shape[y][x]) {
                const boardY = position.y + y;
                const boardX = position.x + x;
                if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                  displayBoard[boardY][boardX] = currentPiece.color;
                }
              }
            }
          }
        }

        return displayBoard;
      };

      const renderNextPiece = () => {
        if (!nextPiece) return null;
        return (
          <div className="flex flex-col items-center gap-0.5">
            {nextPiece.shape.map((row, y) => (
              <div key={y} className="flex gap-0.5">
                {row.map((cell, x) => (
                  <div
                    key={x}
                    className={\`w-4 h-4 sm:w-5 sm:h-5 rounded-sm \${cell ? \`\${nextPiece.color} shadow-md\` : 'bg-transparent'}\`}
                  />
                ))}
              </div>
            ))}
          </div>
        );
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center p-4">
          <div className="flex flex-col lg:flex-row gap-6 items-center">
            {/* Game Board */}
            <div className="relative">
              <div className="absolute inset-0 bg-gradient-to-br from-cyan-500/20 to-purple-500/20 blur-3xl" />
              <div className="relative bg-slate-900/90 backdrop-blur-sm p-3 rounded-2xl border border-slate-700/50 shadow-2xl">
                <div className="flex flex-col gap-0.5 bg-slate-950 p-2 rounded-xl">
                  {renderBoard().map((row, y) => (
                    <div key={y} className="flex gap-0.5">
                      {row.map((cell, x) => (
                        <div
                          key={x}
                          className={\`w-5 h-5 sm:w-6 sm:h-6 rounded-sm transition-all duration-75 \${cell ? \`\${cell} shadow-lg\` : 'bg-slate-800/50 border border-slate-700/30'}\`}
                        />
                      ))}
                    </div>
                  ))}
                </div>
              </div>

              {/* Game Over / Pause Overlay */}
              {(gameOver || isPaused || !isPlaying) && (
                <div className="absolute inset-0 bg-slate-900/80 backdrop-blur-sm flex items-center justify-center rounded-2xl">
                  <div className="text-center">
                    {gameOver ? (
                      <>
                        <h2 className="text-3xl font-bold text-white mb-2">ゲームオーバー</h2>
                        <p className="text-slate-400 mb-4">スコア: {score.toLocaleString()}</p>
                      </>
                    ) : isPaused ? (
                      <h2 className="text-3xl font-bold text-white mb-4">一時停止</h2>
                    ) : (
                      <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 mb-4">
                        テトリス
                      </h2>
                    )}
                    <Button
                      onClick={gameOver || !isPlaying ? startGame : () => setIsPaused(false)}
                      className="bg-gradient-to-r from-cyan-500 to-purple-500 hover:from-cyan-600 hover:to-purple-600 text-white px-6"
                    >
                      <span className="inline-flex items-center">
                        <Icon.Play className="w-4 h-4 mr-2" />
                        {gameOver || !isPlaying ? (gameOver ? 'もう一度' : 'スタート') : '再開'}
                      </span>
                    </Button>
                  </div>
                </div>
              )}
            </div>

            {/* Side Panel */}
            <div className="flex flex-col gap-4 w-full lg:w-48">
              {/* Stats */}
              <div className="bg-slate-800/50 backdrop-blur-sm rounded-xl p-4 border border-slate-700/50">
                <div className="space-y-3">
                  <div>
                    <p className="text-xs text-slate-500 uppercase tracking-wider">スコア</p>
                    <p className="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400">
                      {score.toLocaleString()}
                    </p>
                  </div>
                  <div className="flex gap-4">
                    <div>
                      <p className="text-xs text-slate-500 uppercase tracking-wider">ライン</p>
                      <p className="text-lg font-semibold text-white">{lines}</p>
                    </div>
                    <div>
                      <p className="text-xs text-slate-500 uppercase tracking-wider">レベル</p>
                      <p className="text-lg font-semibold text-white">{level}</p>
                    </div>
                  </div>
                </div>
              </div>

              {/* Next Piece */}
              <div className="bg-slate-800/50 backdrop-blur-sm rounded-xl p-4 border border-slate-700/50">
                <p className="text-xs text-slate-500 uppercase tracking-wider mb-3">次のブロック</p>
                <div className="flex justify-center py-2">
                  {renderNextPiece()}
                </div>
              </div>

              {/* Controls */}
              <div className="flex gap-2">
                <Button
                  onClick={() => setIsPaused(prev => !prev)}
                  disabled={!isPlaying || gameOver}
                  className="flex-1 border-slate-700 hover:bg-slate-700"
                >
                  {isPaused ? <Icon.Play className="w-4 h-4" /> : <Icon.Pause className="w-4 h-4" />}
                </Button>
                <Button
                  onClick={startGame}
                  className="flex-1 border-slate-700 hover:bg-slate-700"
                >
                  <Icon.RotateCcw className="w-4 h-4" />
                </Button>
              </div>

              {/* Mobile Controls */}
              <div className="lg:hidden bg-slate-800/50 backdrop-blur-sm rounded-xl p-4 border border-slate-700/50">
                <div className="grid grid-cols-3 gap-2">
                  <div />
                  <Button onTouchStart={rotatePiece} onClick={rotatePiece} className="h-12 w-12 mx-auto border border-slate-700">
                    <Icon.RotateCw className="w-5 h-5" />
                  </Button>
                  <div />
                  <Button onTouchStart={() => moveHorizontal(-1)} onClick={() => moveHorizontal(-1)} className="h-12 w-12 mx-auto border border-slate-700">
                    <Icon.ChevronLeft className="w-5 h-5" />
                  </Button>
                  <Button onTouchStart={hardDrop} onClick={hardDrop} className="h-12 w-12 mx-auto border border-slate-700 bg-slate-700/50">
                    <Icon.ChevronDown className="w-5 h-5" />
                  </Button>
                  <Button onTouchStart={() => moveHorizontal(1)} onClick={() => moveHorizontal(1)} className="h-12 w-12 mx-auto border border-slate-700">
                    <Icon.ChevronRight className="w-5 h-5" />
                  </Button>
                </div>
                <p className="text-xs text-slate-500 text-center mt-3">下ボタン長押しでハードドロップ</p>
              </div>

              {/* Keyboard Hints */}
              <div className="hidden lg:block text-xs text-slate-500 space-y-1">
                <p>← → : 移動</p>
                <p>↑ : 回転</p>
                <p>↓ : 落下</p>
                <p>スペース : ハードドロップ</p>
                <p>P : 一時停止</p>
              </div>
            </div>
          </div>
        </div>
      );
    }

    /* --- マウント --- */
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Tetris />);
  </script>
</body>
</html>
